#!/bin/bash

DB_PATH="./DBMS"
mkdir -p "$DB_PATH"

# Main Menu
main_menu() {
    echo "==============================================="
    echo "        BASH DATABASE MANAGEMENT SYSTEM       "
    echo "==============================================="
    echo "1. Create Database"
    echo "2. List Databases"
    echo "3. Connect To Database"
    echo "4. Drop Database"
    echo "5. Exit"
    echo "==============================================="
    read -p "Choose an option: " choice
    case $choice in
        1) create_database ;;
        2) list_databases ;;
        3) connect_database ;;
        4) drop_database ;;
        5) echo "Goodbye!"; exit ;;
        *) echo "Invalid option"; main_menu ;;
    esac
}

create_database() {
    echo "==============================================="
    echo "              CREATE DATABASE                 "
    echo "==============================================="
    read -p "Enter database name: " dbname
    
    # Validate database name
    if [[ ! "$dbname" =~ ^[a-zA-Z][a-zA-Z0-9_]*$ ]]; then
        echo "Invalid database name. Must start with letter and contain only letters, numbers, and underscores."
        main_menu
        return
    fi
    
    if [ -d "$DB_PATH/$dbname" ]; then
        echo "Database '$dbname' already exists!"
    else
        mkdir "$DB_PATH/$dbname"
        echo "Database '$dbname' created successfully!"
    fi
    main_menu
}

list_databases() {
    echo "==============================================="
    echo "              LIST DATABASES                  "
    echo "==============================================="
    if [ "$(ls "$DB_PATH" 2>/dev/null)" ]; then
        echo "Available databases:"
        echo "-------------------"
        ls "$DB_PATH" 
    else
        echo "No databases found."
    fi
    echo ""
    main_menu
}

drop_database() {
    echo "==============================================="
    echo "               DROP DATABASE                  "
    echo "==============================================="
    read -p "Enter database name to delete: " dbname
    
    if [ -d "$DB_PATH/$dbname" ]; then
        echo "WARNING: This will permanently delete database '$dbname' and all its tables!"
        read -p "Are you sure? (yes/no): " confirm
        if [[ "$confirm" =~ ^[Yy]([Ee][Ss])?$ ]]; then
            rm -r "$DB_PATH/$dbname"
            echo "Database '$dbname' deleted successfully!"
        else
            echo "Deletion cancelled."
        fi
    else
        echo "Database '$dbname' not found!"
    fi
    main_menu
}

connect_database() {
    echo "==============================================="
    echo "             CONNECT TO DATABASE              "
    echo "==============================================="
    read -p "Enter database name: " dbname
    
    if [ -d "$DB_PATH/$dbname" ]; then
        database_menu "$dbname"
    else
        echo "Database '$dbname' not found!"
        main_menu
    fi
}

# Database Menu (after connecting)
database_menu() {
    local dbname=$1
    echo "==============================================="
    echo "        DATABASE: $dbname"
    echo "==============================================="
    echo "1. Create Table"
    echo "2. List Tables"
    echo "3. Drop Table"
    echo "4. Insert into Table"
    echo "5. Select From Table"
    echo "6. Delete From Table"
    echo "7. Update Table"
    echo "8. Back to Main Menu"
    echo "==============================================="
    read -p "Choose an option: " choice
    case $choice in
        1) create_table "$dbname" ;;
        2) list_tables "$dbname" ;;
        3) drop_table "$dbname" ;;
        4) insert_into_table "$dbname" ;;
        5) select_from_table "$dbname" ;;
        6) delete_from_table "$dbname" ;;
        7) update_table "$dbname" ;;
        8) main_menu ;;
        *) echo "Invalid option"; database_menu "$dbname" ;;
    esac
}

create_table() {
    local dbname=$1
    echo "==============================================="
    echo "              CREATE TABLE                    "
    echo "==============================================="
    read -p "Enter table name: " tablename
    
    # Validate table name
    if [[ ! "$tablename" =~ ^[a-zA-Z][a-zA-Z0-9_]*$ ]]; then
        echo "Invalid table name. Must start with letter."
        database_menu "$dbname"
        return
    fi
    
    if [ -f "$DB_PATH/$dbname/$tablename.txt" ]; then
        echo "Table '$tablename' already exists!"
        database_menu "$dbname"
        return
    fi
    
    read -p "Enter number of columns: " num_cols
    
    # Validate number input
    if ! [[ "$num_cols" =~ ^[0-9]+$ ]] || [ "$num_cols" -lt 1 ]; then
        echo "Invalid number of columns!"
        database_menu "$dbname"
        return
    fi
    
    echo ""
    echo "NOTE! The first column will be the PRIMARY KEY by default"
    
    
    # Arrays to store table metadata
    columns=()
    datatypes=()
    primary_key=""
    
    echo ""
    echo "Enter column details:"
    echo "Available data types: int, string"
    echo "-------------------------------------------"
    
    for ((i=1; i<=num_cols; i++)); do
        read -p "Column $i name: " col_name
        
        # Validate column name
        if [[ ! "$col_name" =~ ^[a-zA-Z][a-zA-Z0-9_]*$ ]]; then
            echo "Invalid column name. Must start with letter."
            i=$((i-1))
            continue
        fi
        
        # Check for duplicate column names
        for existing_col in "${columns[@]}"; do
            if [ "$existing_col" = "$col_name" ]; then
                echo "Error: Column name '$col_name' already exists! Please choose a different name."
                i=$((i-1))
                continue 2  # Continue outer loop
            fi
        done
        
        echo "Select data type for '$col_name':"
        echo "1. int"
        echo "2. string" 
        read -p "Choice (1-2): " dtype_choice
        
        case $dtype_choice in
            1) datatype="int" ;;
            2) datatype="string" ;;
            *) echo "Invalid choice, defaulting to string"; datatype="string" ;;
        esac
        
        columns+=("$col_name")
        datatypes+=("$datatype")
        
        echo "Column '$col_name' ($datatype) added."
        echo ""
    done
    
    # Ask for primary key
    echo "The first column '${columns[0]}' will be set as the primary key."
    primary_key="${columns[0]}"
    
    # Create table files
    # Schema file (tablename_schema.txt) - simplified format
    schema_file="$DB_PATH/$dbname/${tablename}_schema.txt"
    for ((i=0; i<${#columns[@]}; i++)); do
        echo "${columns[i]}:${datatypes[i]}" >> "$schema_file"
    done
    
    # Data file (tablename.txt) - just headers
    data_file="$DB_PATH/$dbname/$tablename.txt"
    {
        printf "%s" "${columns[0]}"
        for ((i=1; i<${#columns[@]}; i++)); do
            printf ",%s" "${columns[i]}"
        done
        printf "\n"
    } > "$data_file"
    
    echo ""
    echo "Table '$tablename' created successfully!"
    database_menu "$dbname"
}

list_tables() {
    local dbname=$1
    echo "==============================================="
    echo "              LIST TABLES                     "
    echo "==============================================="
    
    if [ "$(ls "$DB_PATH/$dbname" 2>/dev/null | grep -E '\.txt$' | grep -v '_schema')" ]; then
        echo "Tables in database '$dbname':"
        echo "-----------------------------"
        ls "$DB_PATH/$dbname"/*.txt 2>/dev/null | grep -v '_schema' | sed 's/.*\///;s/\.txt$//' | nl
    else
        echo "No tables found in database '$dbname'."
    fi
    echo ""
    database_menu "$dbname"
}

drop_table() {
    local dbname=$1
    echo "==============================================="
    echo "               DROP TABLE                     "
    echo "==============================================="
    read -p "Enter table name to delete: " tablename
    
    if [ -f "$DB_PATH/$dbname/$tablename.txt" ]; then
        read -p "Are you sure you want to delete table '$tablename'? (yes/no): " confirm
        if [[ "$confirm" =~ ^[Yy]([Ee][Ss])?$ ]]; then
            rm "$DB_PATH/$dbname/$tablename.txt" 2>/dev/null
            rm "$DB_PATH/$dbname/${tablename}_schema.txt" 2>/dev/null
            echo "Table '$tablename' deleted successfully!"
        else
            echo "Deletion cancelled."
        fi
    else
        echo "Table '$tablename' not found!"
    fi
    database_menu "$dbname"
}

validate_datatype() {
    local value=$1
    local datatype=$2
    
    case $datatype in
        "int")
            if [[ "$value" =~ ^-?[0-9]+$ ]]; then
                return 0
            else
                return 1
            fi
            ;;
        "string")
            return 0  # Any value is valid for string
            ;;
        *)
            return 1
            ;;
    esac
}

insert_into_table() {
    local dbname=$1
    echo "==============================================="
    echo "             INSERT INTO TABLE                "
    echo "==============================================="
    read -p "Enter table name: " tablename
    
    if [ ! -f "$DB_PATH/$dbname/$tablename.txt" ]; then
        echo "Table '$tablename' not found!"
        database_menu "$dbname"
        return
    fi
    
    # Read schema
    schema_file="$DB_PATH/$dbname/${tablename}_schema.txt"
    
    # Get column info - first column is always primary key
    declare -a columns
    declare -a datatypes
    while IFS=: read -r col_name col_type; do
        columns+=("$col_name")
        datatypes+=("$col_type")
    done < "$schema_file"
    
    primary_key="${columns[0]}"  # First column is always primary key
    
    echo ""
    echo "Table: $tablename"
    echo "Columns and data types:"
    for ((i=0; i<${#columns[@]}; i++)); do
        pk_marker=""
        if [ $i -eq 0 ]; then
            pk_marker=" (PRIMARY KEY)"
        fi
        echo "  ${columns[i]} (${datatypes[i]})$pk_marker"
    done
    echo ""
    
    # Input values
    declare -a values
    for ((i=0; i<${#columns[@]}; i++)); do
        while true; do
            read -p "Enter value for ${columns[i]} (${datatypes[i]}): " input_value
            
            # Check if primary key (first column) is null or empty
            if [ $i -eq 0 ]; then
                if [ -z "$input_value" ]; then
                    echo "Error: Primary key cannot be null or empty!"
                    continue
                fi
            fi
            
            if validate_datatype "$input_value" "${datatypes[i]}"; then
                # Check primary key uniqueness (first column is always primary key)
                if [ $i -eq 0 ]; then
                    if [ "$(awk -F, -v val="$input_value" 'NR>1 && $1==val {print}' "$DB_PATH/$dbname/$tablename.txt")" ]; then
                        echo "Error: Primary key value '$input_value' already exists!"
                        continue
                    fi
                fi
                values+=("$input_value")
                break
            else
                echo "Invalid value for datatype ${datatypes[i]}. Please try again."
            fi
        done
    done
    
    # Insert the record
    {
        printf "%s" "${values[0]}"
        for ((i=1; i<${#values[@]}; i++)); do
            printf ",%s" "${values[i]}"
        done
        printf "\n"
    } >> "$DB_PATH/$dbname/$tablename.txt"
    
    echo ""
    echo "Record inserted successfully!"
    database_menu "$dbname"
}

select_from_table() {
    local dbname=$1
    echo "==============================================="
    echo "             SELECT FROM TABLE                "
    echo "==============================================="
    read -p "Enter table name: " tablename
    
    if [ ! -f "$DB_PATH/$dbname/$tablename.txt" ]; then
        echo "Table '$tablename' not found!"
        database_menu "$dbname"
        return
    fi
    
    # Read table headers
    headers=$(head -n 1 "$DB_PATH/$dbname/$tablename.txt")
    IFS=',' read -ra columns <<< "$headers"
    
    echo ""
    echo "Select options:"
    echo "1. Show all data"
    echo "2. Select columns"
    echo "3. Filter rows (WHERE)"
    echo "4. Select columns + Filter rows"
    read -p "Choose (1-4): " choice
    
    case $choice in
        1) show_table "$dbname" "$tablename" ;;
        2) select_columns "$dbname" "$tablename" ;;
        3) filter_rows "$dbname" "$tablename" ;;
        4) select_and_filter "$dbname" "$tablename" ;;
        *) echo "Invalid choice"; select_from_table "$dbname" ;;
    esac
}

# Simple function to display entire table
show_table() {
    local dbname=$1
    local tablename=$2
    echo ""
    echo "Table: $tablename"
    echo "=================="
    cat "$DB_PATH/$dbname/$tablename.txt" | column -t -s ',' 2>/dev/null || cat "$DB_PATH/$dbname/$tablename.txt"
    echo ""
    database_menu "$dbname"
}

# Simple column selection
select_columns() {
    local dbname=$1
    local tablename=$2
    local file="$DB_PATH/$dbname/$tablename.txt"
    
    # Show available columns
    echo ""
    echo "Available columns:"
    head -n 1 "$file" | tr ',' '\n' | nl
    
    echo ""
    read -p "Enter column numbers (Columns must be comma seperated.  e.g. 1,3,5): " selection
    
    # Get total number of columns
    total_cols=$(head -n 1 "$file" | tr ',' '\n' | wc -l)
    
    # Validate column selection
    IFS=',' read -ra cols <<< "$(echo "$selection" | tr -d ' ')"
    for col in "${cols[@]}"; do
        if ! [[ "$col" =~ ^[0-9]+$ ]] || [ "$col" -lt 1 ] || [ "$col" -gt "$total_cols" ]; then
            echo "Error: Invalid column number '$col'! Must be between 1 and $total_cols"
            database_menu "$dbname"
            return
        fi
    done
    
    # Convert selection to cut format
    cut_fields=$(echo "$selection" | tr -d ' ')
    
    echo ""
    echo "Selected columns:"
    echo "=================="
    cut -d',' -f"$cut_fields" "$file" | column -t -s ',' 2>/dev/null || cut -d',' -f"$cut_fields" "$file"
    echo ""
    database_menu "$dbname"
}

# Simple row filtering 
filter_rows() {
    local dbname=$1
    local tablename=$2
    local file="$DB_PATH/$dbname/$tablename.txt"
    
    # Show available columns with numbers
    echo ""
    echo "Available columns:"
    head -n 1 "$file" | tr ',' '\n' | nl
    
    echo ""
    read -p "Enter column number to filter by: " col_num
    read -p "Enter value to match: " value
    
    # Validate column number
    total_cols=$(head -n 1 "$file" | tr ',' '\n' | wc -l)
    if ! [[ "$col_num" =~ ^[0-9]+$ ]] || [ "$col_num" -lt 1 ] || [ "$col_num" -gt "$total_cols" ]; then
        echo "Invalid column number! Must be between 1 and $total_cols"
        database_menu "$dbname"
        return
    fi
    
    echo ""
    echo "Filtering column $col_num for value: '$value'"
    echo "Filtered results:"
    echo "=================="
    
    # Show header first
    head -n 1 "$file" | column -t -s ',' 2>/dev/null || head -n 1 "$file"
    
    
    
    # Core filtering logic
    {
        # Skip header, cut the specific column, find matches, then get original lines
        tail -n +2 "$file" | while IFS= read -r line; do
            field_value=$(echo "$line" | cut -d',' -f"$col_num")
            if [ "$field_value" = "$value" ]; then
                echo "$line"
            fi
        done
    } | column -t -s ',' 2>/dev/null || {
        tail -n +2 "$file" | while IFS= read -r line; do
            field_value=$(echo "$line" | cut -d',' -f"$col_num")
            if [ "$field_value" = "$value" ]; then
                echo "$line"
            fi
        done
    }
    
    echo ""
    database_menu "$dbname"
}

# Combined column selection and row filtering 
select_and_filter() {
    local dbname=$1
    local tablename=$2
    local file="$DB_PATH/$dbname/$tablename.txt"
    
    # Show available columns
    echo ""
    echo "Available columns:"
    head -n 1 "$file" | tr ',' '\n' | nl
    
    # Get column selection
    echo ""
    read -p "Enter column numbers to show (Columns must be comma seperated.  e.g. 1,3,5): " col_selection
    
    # Get filter criteria
    echo ""
    read -p "Enter column number to filter by: " filter_col
    read -p "Enter value to match: " filter_value
    
    # Get total number of columns
    total_cols=$(head -n 1 "$file" | tr ',' '\n' | wc -l)
    
    # Validate column selection
    IFS=',' read -ra cols <<< "$(echo "$col_selection" | tr -d ' ')"
    for col in "${cols[@]}"; do
        if ! [[ "$col" =~ ^[0-9]+$ ]] || [ "$col" -lt 1 ] || [ "$col" -gt "$total_cols" ]; then
            echo "Error: Invalid column number '$col' in selection! Must be between 1 and $total_cols"
            database_menu "$dbname"
            return
        fi
    done
    
    # Validate filter column
    if ! [[ "$filter_col" =~ ^[0-9]+$ ]] || [ "$filter_col" -lt 1 ] || [ "$filter_col" -gt "$total_cols" ]; then
        echo "Invalid filter column number! Must be between 1 and $total_cols"
        database_menu "$dbname"
        return
    fi
    
    # Convert column selection to cut format
    cut_fields=$(echo "$col_selection" | tr -d ' ')
    
    echo ""
    echo "Results:"
    echo "========"
    
    # Show selected column headers
    head -n 1 "$file" | cut -d',' -f"$cut_fields"
    
    # Filter rows and show selected columns
    {
        tail -n +2 "$file" | while IFS= read -r line; do
            field_value=$(echo "$line" | cut -d',' -f"$filter_col")
            if [ "$field_value" = "$filter_value" ]; then
                echo "$line"
            fi
        done
    } | cut -d',' -f"$cut_fields"
    
    echo ""
    database_menu "$dbname"
}

delete_from_table() {
    local dbname=$1
    echo "==============================================="
    echo " DELETE FROM TABLE "
    echo "==============================================="
    read -p "Enter table name: " tablename
    
    if [ ! -f "$DB_PATH/$dbname/$tablename.txt" ]; then
        echo "Table '$tablename' not found!"
        database_menu "$dbname"
        return
    fi
    
    local file="$DB_PATH/$dbname/$tablename.txt"
    
    # Show available columns for selection
    echo ""
    echo "Available columns:"
    head -n 1 "$file" | tr ',' '\n' | nl
    
    echo ""
    read -p "Enter column number to filter by: " col_num
    read -p "Enter value to match for deletion: " delete_value
    
    # Get total number of columns
    total_cols=$(head -n 1 "$file" | tr ',' '\n' | wc -l)
    
    # Validate column number
    if ! [[ "$col_num" =~ ^[0-9]+$ ]] || [ "$col_num" -lt 1 ] || [ "$col_num" -gt "$total_cols" ]; then
        echo "Invalid column number! Must be between 1 and $total_cols"
        database_menu "$dbname"
        return
    fi
    
    # Count rows before deletion
    total_rows_before=$(wc -l < "$file")
    data_rows_before=$((total_rows_before - 1))
    
    
    # Complete the pattern to match the exact value in the specified column
    if [ "$col_num" -eq "$total_cols" ]; then
        # Last column - match until end of line
        sed_script="${sed_script%,\[^,\]\*},${delete_value}$/d"
    else
        # Not last column - match until next comma
        sed_script="${sed_script%,\[^,\]\*},${delete_value},/d"
    fi
    
    # Alternative simpler approach using awk (more reliable)
    awk -v col="$col_num" -v val="$delete_value" '
    BEGIN { FS=OFS="," }
    NR==1 { print; next }  # Always keep header
    $col != val { print }  # Keep rows where column value does not match
    ' "$file" > "${file}.new" && mv "${file}.new" "$file"
    
    # Count rows after deletion
    total_rows_after=$(wc -l < "$file")
    data_rows_after=$((total_rows_after - 1))
    deleted_count=$((data_rows_before - data_rows_after))
    
    echo ""
    if [ "$deleted_count" -eq 0 ]; then
        echo "No rows found matching the criteria."
    else
        echo "Successfully deleted $deleted_count row(s) from table '$tablename'!"
    fi
    
    echo ""
    database_menu "$dbname"
}

# Start the application
main_menu
